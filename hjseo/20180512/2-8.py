#1
a = [1, 2, 3]
b = [1, 2, 3]
print(a is b)
# --> is Func는 주소 값 기준으로 판단
# --> Val이 같다고 해도 주소가 다르면 false

#2
c = [1, 2, 3]
d = c
print(c is d)
# --> "=" 연산은 Python 에서 c의 주소값을 d로 할당으로 봐도 무방
# --> is 연산은 주소값의 같음을 연산 하므로 true

#3
e = f = [1, 2 ,3]
e[1] = 4
print(e)
print(f)
# --> "=" 주소 값 할당 이므로 Val Mem 주소는 변함 없으므로 Val이 바뀌면 할당된
# 모든 변수의 값이 바뀜

#4
g = [1, 2, 3]
h = g[:]
print(g is h)
# --> [:] 연산은 shallow copy라고 보면 됨. value copy 이므로 둘의
# Val Mem 주소가 같을 순 없음 false

#5
h[1] = 4
print(h)
# --> #4에서 설명함

#6
a1 = [1, 2, 3]
print(id(a1))
a1 = a1 + [4, 5]
print(id(a1))

a2 = [1, 2, 3]
print(id(a2))
a2.extend([4, 5])
print(id(a2))
# --> a1 이란 변수에 + 연산 후 다시 대입 했지만, + 연산 특성상 새로운 Mem 공간을 할당후 
# a1에 shallow copy 것으로 보임 
# 때문에 + 전 a1과 + 후 a1 객체 id가 다름

# extend 함수는 대입된 string 객체(a2)에 내부적으로 직접 추가 하는 형식으로 보임.
# 때문에 id가 같음

#7
a3 = [11, [4,5], 4]
b3 = a3[:]

a3[1][0] = 5
print(a3)
print(b3)
# Shallow copy가 객체를 복사 할때, a3[0], a3[1], a[3]... 의 주소만
# 복사하는 걸로 보인다.
# List의 주소만 b3에 복사 된다면, b3의 1번째 값 주소(List의 주소)는
# Mem에서 살아있는 한, a3[1] 접근으로 데이터가 변할 수 있다.(List 객체가 불변 객체가 아니고 a[1]과 b[1] 주소가 같으므로)
##################### 확인 코드##################
#b3 = []
#b3.append(a3[0])
#b3.append(a3[1][:])
#b3.append(a3[2])
#################################################
# [:](shallow copy 말고) 위 코드로 copy시 원하는 결과가 나오는 걸 알 수 있다.
